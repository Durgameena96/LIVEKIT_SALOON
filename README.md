üíá‚Äç‚ôÄÔ∏è Salon AI Assistant ‚Äì LiveKit + Firebase + Flask

A simulated AI call agent that can answer customer questions using a basic knowledge base, escalate to a human supervisor if needed, and update itself based on new info ‚Äî built with LiveKit, Python, Firebase, and Flask.


## üöÄ Features

- Simulated AI call handler (via LiveKit + Python logic)
- Basic Q&A knowledge base
- Help request escalation to supervisor
- Internal admin panel (Flask) for resolving customer questions
- Auto-updating UI (AJAX polling)
- Knowledge base auto-learning from supervisor input
- Simple Firestore schema and lifecycle handling

## üß† Architecture
LIVEKIT_SALOON/
‚îÇ
‚îú‚îÄ‚îÄ agent.py            # Main AI logic
‚îú‚îÄ‚îÄ knowledge_base.py   # Simple Q&A storage
‚îú‚îÄ‚îÄ help_request.py     # Help request DB model
|___app.py              # To handle API calls for storage, history, pending requests from UI
‚îú‚îÄ‚îÄ .env                # LIVEKIT API keys and url
‚îú‚îÄ‚îÄ firebase_init.py    # To Initialize firebase configuration and certificate
|__ templates           # For the UI screen with html and app calls
‚îÇ   ‚îú‚îÄ‚îÄ index.html         # View + respond to help requests
‚îÇ   ‚îú‚îÄ‚îÄ history.html       # View all resolved/unresolved
‚îÇ   ‚îî‚îÄ‚îÄ layout.html        # Shared HTML layout
‚îî‚îÄ‚îÄ README.md


I have installed the following: 
pip install livekit
pip install livekit-api
pip install firebase-admin

After installed Generated the LIVEKIT_API_KEY and LIVEKIT_API_SECRET from Livekit portal.
And i have installed firebase for the storage.

**Created a Basic Knowledge Base**
KNOWN_QUESTIONS = {
    "what are your hours": "We are open from 9am to 6pm, Monday to Saturday.",
    "where are you located": "We are at 123 Main Street, Springfield."
}

def get_answer(question):
    normalized = question.lower().strip()
    return KNOWN_QUESTIONS.get(normalized)

Created Agent.py : Code for Simulate a Call Handling Agent. 
   agent.py handles Receiving the call or chat input (simulate via function). Checks knowledge_base.py for an answer. If unknown, triggers help_request.py.create_help_request().

knowledge_base.py:   Stores Q&A pairs in a simple dictionary or a Firestore collection.
help_request.py:  Interacts with Firebase Firestore to create and resolve help requests.

**Help Request: Elegant Firestore Data Model**
Firestore Collection: help_requests
Each help request is a document. Here's a suggested schema:
{
  "id": "auto-generated by Firestore",
  "customer_id": "123456",          // UUID or phone number
  "question": "Do you offer gift cards?",
  "status": "pending",              // pending | resolved | unresolved
  "created_at": "2025-05-01T12:34:56Z",   // timestamp for lifecycle tracking
  "resolved_at": null,              // populated when status is updated
  "response": null,                // supervisor's response, if resolved
  "handled_by": null               // supervisor's ID (optional)
}

**Benefits of this Schema**
Scalable: Indexed on status and created_at, ideal for querying pending/resolved requests.

Lifecycle-Aware: Supports Pending ‚Üí Resolved/Unresolved with timestamps.

Auditable: Tracks who responded (handled_by) and when.

**help_request.py: Create the help request

I have used Python with Flask and Firestore for the backend, and basic HTML templates for the UI.


Run the app by **python agent.py**  

what are your hours
It should respond with a known answer.

Ask something unknown:
do you have discounts?
It should say it's escalating to a supervisor and log the help request.

In another terminal run **flask run**
Visit http://localhost:5000 to see the UI
![image](https://github.com/user-attachments/assets/d955d2fe-c2fa-470c-8982-2e3a030ed222)




In our Flask app,I am using this code to query pending help requests:

@app.route('/')
def index():
    docs = db.collection('help_requests').where('status', '==', 'pending').stream()
    requests = [doc.to_dict() | {'id': doc.id} for doc in docs]
    return render_template('index.html', requests=requests)

This:

> Connects to Firestore (db)
> Queries the help_requests collection
> Filters documents where status == "pending"
Passes that data to the template

> In templates/index.html, the pending requests are shown like this:
This is dynamically displaying all pending questions and rendering a response form for each one.
![image](https://github.com/user-attachments/assets/8b49842a-1cc1-442e-8fb3-af53039c014c)


***Full Data Flow (End-to-End)***
1.AI agent receives a question it doesn‚Äôt know and runs:

create_help_request(question="Do you offer discounts?", customer_id="abc-123")

Which stores a new Firestore document:
{
  "question": "Do you offer discounts?",
  "status": "pending",
  ...
}

2. Supervisor UI (GET /) loads and queries Firestore:
db.collection('help_requests').where('status', '==', 'pending').stream()
3. The UI shows pending requests in a form (with a text box and "Submit" button).

4. Supervisor responds, and Flask handles the POST /respond/<id> route:
   db.collection('help_requests').document(id).update({
    'status': 'resolved',
    'response': answer,
    ...

})
5.After updating the status, simulating texting back the customer by logging to the console:
    print(f"[Texted back customer] Answer: {answer}")
6. The UI will auto-refresh every 5 seconds and load any new pending requests.
   Supervisor doesn‚Äôt need to refresh the page.


***Key Design Decisions***
Simulated AI Agent Using LiveKit + Python

I choose to use the LiveKit Python SDK to simulate a basic call-handling AI agent. Since LiveKit doesn‚Äôt have a high-level voice bot wrapper, I focused on simulating calls and triggering AI logic through Python functions.

The agent checks a simple knowledge base for answers and triggers a human help request if it doesn't know the answer.

1. Lightweight Knowledge Base

I implemented a dictionary-based knowledge store (knowledge_base.py) for simplicity and fast access. This makes it easy to update the agent‚Äôs memory once a supervisor provides an answer.

2. Elegant Firestore Help Request Model

Help requests are stored in Firebase Firestore with clearly defined fields like status, customer_id, question, response, resolved_at, and handled_by.
This structure enables a clean request lifecycle: pending ‚Üí resolved/unresolved.

3. Simple Admin UI (Flask)

I used Flask to build an internal admin panel where supervisors can view pending requests, submit answers, and view history.

Auto-refresh is handled via JavaScript polling every 5 seconds to ensure supervisors always see the latest requests without manual reloads.

4. Immediate Follow-Up After Supervisor Response

Once the supervisor submits a response, the AI agent logs a simulated ‚Äútext back‚Äù and updates its knowledge base with the new info to avoid repeated supervisor queries.


***Supervisor Timeout Handling***

I would implement a background job or cloud function to mark requests as "unresolved" if not handled within a set time window (e.g., 5 minutes), and notify the original user accordingly.

1. Real-Time Updates with Firebase Listeners

To improve responsiveness, I‚Äôd replace the JavaScript polling with Firebase real-time listeners so supervisors get instantly notified when new requests come in.

2.Persistent Knowledge Base

Currently, the knowledge base is in-memory. I‚Äôd migrate it to a Firestore-backed collection or lightweight vector DB for more robust long-term storage and querying.

3. Scalability Enhancements

To prepare for scaling to 1,000+ requests/day, I‚Äôd modularize the system further:
Move AI logic into a separate service or microservice.
Add request batching or indexing in Firestore for faster filtering.

Use Firebase Cloud Functions for push notifications and async logic.

4. Testing and Error Handling

I‚Äôd add unit tests for all major logic paths (agent routing, DB operations).

Implement error logging (e.g., to Firebase Crashlytics or Sentry) for better monitoring in production.
