

I have installed the following: 
pip install livekit
pip install livekit-api
pip install firebase-admin


After installed Generated the LIVEKIT_API_KEY and LIVEKIT_API_SECRET from Livekit portal.
And i have installed firebase for the storage.

I have created the project with following structure

my-salon-agent/
│
├── agent.py            # Main AI logic
├── knowledge_base.py   # Simple Q&A storage
├── help_request.py     # Help request DB model
|___app.py              # To handle API calls for storage, history, pending requests from UI
├── .env                # LIVEKIT API keys and url
├── firebase_init.py    # To Initialize firebase configuration and certificate
|__ templates           # For the UI screen with html and app calls
│   ├── index.html         # View + respond to help requests
│   ├── history.html       # View all resolved/unresolved
│   └── layout.html        # Shared HTML layout
└── README.md


**Created a Basic Knowledge Base**
KNOWN_QUESTIONS = {
    "what are your hours": "We are open from 9am to 6pm, Monday to Saturday.",
    "where are you located": "We are at 123 Main Street, Springfield."
}

def get_answer(question):
    normalized = question.lower().strip()
    return KNOWN_QUESTIONS.get(normalized)

Created Agent.py : Code for Simulate a Call Handling Agent. 
   agent.py handles Receiving the call or chat input (simulate via function). Checks knowledge_base.py for an answer. If unknown, triggers help_request.py.create_help_request().

knowledge_base.py:   Stores Q&A pairs in a simple dictionary or a Firestore collection.
help_request.py:  Interacts with Firebase Firestore to create and resolve help requests.

**Help Request: Elegant Firestore Data Model**
Firestore Collection: help_requests
Each help request is a document. Here's a suggested schema:

jsonc
Copy
Edit
{
  "id": "auto-generated by Firestore",
  "customer_id": "123456",          // UUID or phone number
  "question": "Do you offer gift cards?",
  "status": "pending",              // pending | resolved | unresolved
  "created_at": "2025-05-01T12:34:56Z",   // timestamp for lifecycle tracking
  "resolved_at": null,              // populated when status is updated
  "response": null,                // supervisor's response, if resolved
  "handled_by": null               // supervisor's ID (optional)
}

**Benefits of this Schema**
Scalable: Indexed on status and created_at, ideal for querying pending/resolved requests.

Lifecycle-Aware: Supports Pending → Resolved/Unresolved with timestamps.

Auditable: Tracks who responded (handled_by) and when.

**help_request.py: Create the help request

I have used Python with Flask and Firestore for the backend, and basic HTML templates for the UI.


Run the app by **python agent.py**  

what are your hours
It should respond with a known answer.

Ask something unknown:
do you have discounts?
It should say it's escalating to a supervisor and log the help request.

In another terminal run **flask run**
Visit http://localhost:5000 to see the UI
![image](https://github.com/user-attachments/assets/d955d2fe-c2fa-470c-8982-2e3a030ed222)




In our Flask app,I am using this code to query pending help requests:

@app.route('/')
def index():
    docs = db.collection('help_requests').where('status', '==', 'pending').stream()
    requests = [doc.to_dict() | {'id': doc.id} for doc in docs]
    return render_template('index.html', requests=requests)

This:

> Connects to Firestore (db)
> Queries the help_requests collection
> Filters documents where status == "pending"
Passes that data to the template

> In templates/index.html, the pending requests are shown like this:
This is dynamically displaying all pending questions and rendering a response form for each one.
![image](https://github.com/user-attachments/assets/8b49842a-1cc1-442e-8fb3-af53039c014c)


**Full Data Flow (End-to-End)**
1.AI agent receives a question it doesn’t know and runs:

create_help_request(question="Do you offer discounts?", customer_id="abc-123")

Which stores a new Firestore document:
{
  "question": "Do you offer discounts?",
  "status": "pending",
  ...
}

2. Supervisor UI (GET /) loads and queries Firestore:
db.collection('help_requests').where('status', '==', 'pending').stream()
3. The UI shows pending requests in a form (with a text box and "Submit" button).

4. Supervisor responds, and Flask handles the POST /respond/<id> route:
   db.collection('help_requests').document(id).update({
    'status': 'resolved',
    'response': answer,
    ...

})
5.After updating the status, simulating texting back the customer by logging to the console:
    print(f"[Texted back customer] Answer: {answer}")
6. The UI will auto-refresh every 5 seconds and load any new pending requests.
   Supervisor doesn’t need to refresh the page.

